# Decision Log

Этот файл фиксирует архитектурные и исполнительские решения в формате списка.
2025-04-12 21:50:00 - Создание файла.

## Решение: Основная архитектура приложения

* **Описание:** Принято решение использовать компонентную архитектуру React с функциональными компонентами и хуками.

* **Обоснование:** 
  - Современный подход к разработке React-приложений
  - Лучшая производительность и меньший размер бандла по сравнению с классовыми компонентами
  - Легче поддерживать и тестировать
  - Более удобное разделение логики с использованием хуков

* **Детали реализации:**
  - Использование функциональных компонентов для всех элементов UI
  - Применение React Hooks (useState, useEffect, useContext, useReducer, useCallback, useMemo) для управления состоянием
  - Создание пользовательских хуков для инкапсуляции игровой логики
  - Применение паттерна "Compound Components" для сложных UI-элементов

## Решение: Структура проекта

* **Описание:** Определена структура проекта согласно ТЗ с четким разделением компонентов, игровой логики и ресурсов.

* **Обоснование:**
  - Логическое разделение ответственностей
  - Упрощение навигации по проекту
  - Соответствие принципу единой ответственности
  - Возможность переиспользования компонентов

* **Детали реализации:**
  - Директории верхнего уровня разделены по функциональности
  - Игровые компоненты отделены от UI-компонентов
  - Игровая логика вынесена в отдельные модули
  - Константы, типы и утилиты разделены для лучшей организации

## Решение: Выбор Vite вместо Create React App

* **Описание:** Выбран Vite в качестве инструмента сборки вместо Create React App.

* **Обоснование:**
  - Более быстрая скорость разработки и сборки
  - Меньшее потребление ресурсов
  - Современный подход к сборке на основе ESM
  - Лучшая поддержка TypeScript из коробки

* **Детали реализации:**
  - Использован шаблон react-ts для Vite
  - Настроен ESLint и Prettier для обеспечения качества кода
  - Оптимизирована конфигурация для разработки и продакшена

## Решение: Использование styled-components для стилизации

* **Описание:** Выбрана библиотека styled-components для стилизации компонентов.

* **Обоснование:**
  - Инкапсуляция стилей в компонентах
  - Динамическая стилизация на основе пропсов
  - Устранение конфликтов стилей между компонентами
  - Удобство управления темами и цветовыми схемами

* **Детали реализации:**
  - Использование префикса $ для пропсов стилей для избежания конфликтов с DOM-атрибутами
  - Создание общих констант для цветов и стилей
  - Применение глобальных стилей через createGlobalStyle
|
## Решение: Использование ref для преодоления асинхронности обновления состояния
|
* **Описание:** Добавлен useRef для хранения текущей выбранной фигуры и преодоления проблем с асинхронным обновлением состояния React.
|
* **Обоснование:**
  - Обновление state в React асинхронно, что вызывает проблемы при быстрых операциях drag-and-drop
  - Ref обновляется синхронно и доступен немедленно
  - Данный подход позволяет более надежно отслеживать состояние в событиях пользовательского ввода
|
* **Детали реализации:**
  - Добавлен selectedShapeRef для хранения текущей выбранной фигуры
  - Реализована логика fallback между state и ref для обеспечения стабильности
  - Добавлены проверки типов для безопасной работы с nullable значениями
|
## Решение: Оптимизация кода через удаление отладочных элементов и неиспользуемого кода
|
* **Описание:** Проведена оптимизация кода путем удаления избыточных комментариев, отладочных сообщений и неиспользуемого кода.
|
* **Обоснование:**
  - Улучшение читаемости кода
  - Снижение размера бандла
  - Упрощение поддержки и дальнейшей разработки
|
* **Детали реализации:**
  - Удалены избыточные комментарии, не относящиеся к документации функций
  - Удалены или минимизированы отладочные console.log вызовы
  - Упрощена структура условных выражений и обработки ошибок
|
## Решение: Использование transform вместо position:fixed для перемещения фигур

* **Описание:** Механизм перемещения фигур переработан с использованием CSS transform вместо position:fixed

* **Обоснование:**
  - Использование transform обеспечивает более плавную анимацию, задействуя GPU вместо CPU
  - Улучшение пользовательского опыта за счет более плавного перемещения фигур
  - Снижение вероятности скачков и неправильного позиционирования
  - Более эффективное использование ресурсов браузера

* **Детали реализации:**
  - Расширена структура DraggableShapeInfo для хранения информации о начальной позиции и перемещении
  - Реализован расчет трансформации на основе движения курсора относительно начальной точки
  - Обновлены стили для использования CSS свойства transform вместо top и left
  - Реализован двухэтапный механизм возврата фигуры на место при неудачном перетаскивании
  - Добавлены обработчики для корректного вычисления смещения на основе начальной позиции элемента

## Решение: Рефакторинг компонента GameController.tsx

* **Описание:** Разделение большого компонента GameController.tsx на более мелкие и специализированные компоненты

* **Обоснование:**
 - Улучшение поддерживаемости кода через разделение ответственности
 - Уменьшение сложности отдельных компонентов
 - Упрощение тестирования функциональности
 - Следование принципу единственной ответственности (Single Responsibility Principle)

* **Детали реализации:**
 - Созданы компоненты MobileGameLayout и DesktopGameLayout для отображения на разных устройствах
 - Реализован хук useGhostPosition для инкапсуляции логики "призрака" фигуры
 - Оптимизирован хук useDragAndDrop для улучшения взаимодействия с управлением "призраком"
 - Добавлена адаптивная логика для определения типа устройства и соответствующего отображения
 - Создан компонент GameOverPanel для отображения состояния завершения игры

## Решение: Оптимизация управления "призраком" фигуры

* **Описание:** Централизация управления "призраком" фигуры для предотвращения конфликтов состояния

* **Обоснование:**
 - Устранение проблем с дублированием состояния в разных компонентах
 - Более логичное распределение ответственности между компонентами
 - Упрощение отладки при возникновении проблем с отображением

* **Детали реализации:**
 - Основное управление "призраком" вынесено в компонент GameController
 - В хук useDragAndDrop передаются только функции управления без дублирования состояния
 - Устранены потенциальные race conditions при параллельном обновлении состояния
 - Улучшена связь между визуальным отображением и логикой управления

## Решение: Переработка системы подсветки очищаемых линий

* **Описание:** Изменена система подсветки очищаемых линий с целью увеличения наглядности и улучшения визуальной обратной связи

* **Обоснование:**
  - Предыдущая система подсветки целых линий была недостаточно заметной для игрока
  - Нужен более интерактивный и привлекающий внимание визуальный эффект
  - Подсветка отдельных ячеек вместо целых строк и столбцов обеспечивает лучшую визуальную обратную связь
  - Унификация подхода с "призраком" фигуры, когда эффект применяется к отдельным ячейкам

* **Детали реализации:**
  - Удален отдельный компонент LineHighlighter.tsx
  - Внедрена подсветка конкретных ячеек прямо в компонент Grid
  - Добавлены более выразительные анимационные эффекты:
    - Изменение цвета от золотого к оранжево-красному
    - Эффект свечения с помощью box-shadow
    - Анимация "потряхивания" с помощью rotate
    - Эффект пульсации с изменением размера
  - Улучшенная анимация делает подсветку более заметной и привлекающей внимание

## Решение: Удаление дублирующего компонента GhostShape.tsx

* **Описание:** Удален компонент GhostShape.tsx, создававший дублирование отображения "призрака" фигуры

* **Обоснование:**
  - В проекте существовало два разных механизма для отображения "призрака" фигуры:
    1. Компонент GhostShape.tsx - отдельный React-компонент
    2. Встроенный механизм призрака в Grid.tsx через стили Grid.styles.ts
  - Это приводило к дублированию "призрака" в некоторых местах сетки
  - Первые две ячейки первой и второй строки дублировали призрак фигуры в других местах
  - Призрак некорректно отображался в последней строке сетки

* **Детали реализации:**
  - Удален компонент GhostShape.tsx
  - Удалены импорты GhostShape из MobileGameLayout.tsx и DesktopGameLayout.tsx
  - Удалены вызовы компонента GhostShape в MobileGameLayout.tsx и DesktopGameLayout.tsx
  - Оставлен только один механизм отображения "призрака" через Grid.styles.ts и Grid.tsx
  - Обновлены файлы memory-bank для отражения изменений